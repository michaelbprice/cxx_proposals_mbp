<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>

  <meta http-equiv="Content-Type" content="text/html;charset=US-ASCII">

<!-- This should replace the style block once it is published somewhere accessible
  <link href="../../base_www/style.hinc" rel="stylesheet" type="text/css" />
-->

  <style type="text/css">

    body { color: #000000; background-color: #FFFFFF; }
    del { text-decoration: line-through; color: #8B0040; }
    ins { text-decoration: underline; color: #005100; }

    p.example { margin-left: 2em; }
    pre.example { margin-left: 2em; }
    div.example { margin-left: 2em; }

    code.extract { background-color: #F5F6A2; }
    pre.extract { margin-left: 2em; background-color: #F5F6A2;
      border: 1px solid #E1E28E; }

    p.function { }
    .attribute { margin-left: 2em; }
    .attribute dt { float: left; font-style: italic;
      padding-right: 1ex; }
    .attribute dd { margin-left: 0em; }

    blockquote.std { color: #000000; background-color: #F1F1F1;
      border: 1px solid #D1D1D1;
      padding-left: 0.5em; padding-right: 0.5em; }
    blockquote.stddel { text-decoration: line-through;
      color: #000000; background-color: #FFEBFF;
      border: 1px solid #ECD7EC;
      padding-left: 0.5empadding-right: 0.5em; ; }

    blockquote.stdins { text-decoration: underline;
      color: #000000; background-color: #C8FFC8;
      border: 1px solid #B3EBB3; padding: 0.5em; }

    table { border: 1px solid black; border-spacing: 0px;
      margin-left: auto; margin-right: auto; }
    th { text-align: left; vertical-align: top;
      padding-left: 0.8em; border: none; }
    td { text-align: left; vertical-align: top;
      padding-left: 0.8em; border: none; }
      
    table.docinfo { border: none; border-spacing: 0px;
      margin-left: auto; margin-right: none; float: right; }

  </style>

  <title>Keep comparison operator semantics consistent</title>

</head>

<body>
  <table border="1" class="docinfo">
    <tr> <th>Doc. No.:</th> <td>D????</td> </tr>
    <tr> <th>Date:</th>     <td>2014-11-26</td> </tr>
    <tr> <th>Project:</th>  <td>Programming Language C++, Evolution Working Group</td> </tr>
    <tr> <th>Reply To:</th> <td>Michael Price<br/>
                                &lt;<a href="mailto:michael.b.price.dev@gmail.com">michael.b.price.dev@gmail.com</a>&gt;</td> </tr>
  </table>
  
  <br/>
  <h1>Keep comparison operator semantics consistent</h1>

  <h2><a name="introduction">I. Introduction</a></h2>

  <p>
    Provides an argument for keeping the semantics of any compiler-generated comparison
    operators consistent with those of other compiler-generated special member functions.
  </p>

  <h2><a name="motivation">II. The Details</a></h2>

  <p>
    Given the following types and their relationships
  </p>

  <pre class="example">
  <code>struct Base {
      std::string name;
  };

  class Member {
      int value;
  };

  class MyType : public Base {
      mutable Member member;
      std::string * id;
  };</code>
  </pre>

  <p>
    We have existing rules that determine what happens during the default constructor
    of <code>MyType</code>; namely that the <code>Base</code> constructor gets invoked
    first, followed by the members of <code>MyType</code> in the order in which they
    were declared. Of course, we have similar rules for destruction, copy, and move
    special member functions. Tellingly, we have no special considerations for the base
    and member types to avoid undesired behavior.  We've left it to the designer of
    <code>MyType</code> to understand whether the generated special member functions
    satisfy the requirements for the type, and if they do not, they are free to
    implement the desired semantics.
  </p>

  <p>
    In the papers and discussions about adding comparison operators to the set of
    special member functions that can be generated by an implementation, there has been
    significant discussion about whether or not <code>mutable</code> and pointer members
    should be treated in special ways for comparisons. The general argument is that
    while pointers can be compared for equality just fine, that currently an ordered
    comparison results in undefined behavior. For <code>mutable</code>, the argument
    is that the act of copying a const-qualified object should result in the two objects
    that are "equal", so since the act of copying might change the state of a mutable
    member, they cannot participate in the comparison operations.
  </p>
     
  <p>
    The answer to both of these objections is the same as the answer we've always
    provided in the case where generated special member functions were not sufficient:
    <em>feel free to explicity provide an implementation</em>. If you have a pointer
    member, it is quite probable that you want to perform a deep comparison anyways,
    just like you would provide a deep copy instead of just copying the pointer value
    to the new object.
  </p> 

  <p>
    One unfortunate aspect of this approach is that it forces the ordering to match that
    of the other special member functions, which could be far from ideal.  Again, that is
    why the designer can always implement an ideal ordering for comparison, which they
    unfortunately (or perhaps fortunately) cannot do with the other special member
    functions.
  </p>

</body>
</html>
